Item 1: Consider static factory methods instead of constructors（考虑以静态工厂方法代替构造函数）
应用场景：
见名知义：类的构造器并就不能很好说明其功能时，可以使用静态工厂对外开放的构造器以见名义，java.math.BigInteger#probablePrime就是一个经典的使用案例
定制对象创建：定制对象创建逻辑
静态工厂可以自定义实例的创建逻辑，比如单例对象，基于缓存的对象创建过程
返回子类-案例一：java.util.EnumSet#noneOf，静态工厂可以在不同场景或者参数下返回不同的子类对象，这个为一个功能单位内部的对象创建提供了重要扩展方式
返回子类-案例二：JDBC返回一个特定服务提供者子类


风险：
不能实例化非公开的子类：静态工厂的一个优势是基于返回子类的扩展，但若子类不公开构造器，那静态工厂就不能实例化此子类实例
增加调试难度和代码复杂度：静态工厂可以封装对象的创建，但因此也带来阅读源码和进行代码高度的复杂度，很难定位真正被实例化的类型（特别是在创建子类的场景下）
扩展知识
  服务提供者框架-基本概念
服务接口（标准）与各厂商服务接口的实现方案
服务接口与实现方案的绑定（提供者注册API）：将某一厂商的服务接口注册到服务提供者框架中作为实现方案
客户端获取服务实例：客户端获取注册好的一个服务实现并使用相应的服务，可考虑使用静态工厂方法实现
服务提供者框架-案例-JDBC
Java提出了JDBC的一组服务接口作为标准，各厂商根据标准提供相应的实现方案，用户可自行选择不同厂商提供的实现方案。
JDBC中Connection就是其中的一个服务接口（标准），Driver是某个厂商提供的符合标准的实现方法，用户可能通过调用DriverManager.registerDrive注册指定的厂商的实现方案
JBDC允许同时注册多个厂商的实现方案，用户可以通过DriverManager.getConnection选定其中一个厂商的实现方案
这时在实例化JBDC服务接口的实例时相应的静态工厂就需要返回用户指定的厂商提供的实现子类


java源码使用静态工厂方法的案例
from：java.util.Date#from
of:java.util.EnumSet
valueOf:java.math.BigInteger#valueOf(int[])
instance&getInstance：java.lang.StackWalker#getInstance()
create&newInstance:java.lang.reflect.Array#newInstance(java.lang.Class<?>, int)
getType:java.nio.file.Files#getFileStore
newType：java.nio.file.Files#newBufferedReader(java.nio.file.Path)
Type:java.util.Collections#list


关于Java源码的静态工厂的一些说明
静态工厂构造器提供了传统构造器以外创建实例的更灵活思路，构造器与静态工厂都应该要保留使用，在不同场景下灵活选择不必拘泥一种。
java.nio.file.Files：是java提供一组有关操作文件的封装，其实一些跟文件有关的类，这些类实例创建就集中在Files中。这样的处理使得文件相关的操作类都集中在一个Files类，减轻了开发者对API的记忆和使用负担。
Item 2: Consider a builder when faced with many constructor parameters（当构造函数有多个参数时，考虑改用构建器）
创建多个参数的对象的可选的方案
可伸缩构造函数模式：参数过多时会造成失控，构造器任意组合会直接导致代码失控
 JavaBean 模式（setter方法）：造成构建过程对象的创建状态不一致，特别是使用javaBean时
构建器方案：复杂一些，但可以比较完美地解决多参数的对象创建问题
 构建器方案：
定义：类内部定义一个构建器，创建对象时先由构建器收集所有的构造参数，再由构建器创建目标对象
最佳实践：com.chen.effectivejava.item2.Class1.Builder
构建器通常是静态内部类
构建器收集参数时支持链式调用
考虑将必传的构造器参数作为构建器的构造参数
构建器创建对象时使用build()方法
使用构建器的对象有多个构造器参数，一般不对外开放构造器:com.chen.effectivejava.item2.Class1#Class1
 拓展-继承体系下的Builder:com.chen.effectivejava.item2.PClass
问题1
描述：父类与子类中的构造器参数应该由各自的构建器负责收集并要求收集参数构建器需要支持链式调用，这里就存在父类与子类链式调用返回各自类型的构建器而构建子类时会使用父类的变量。
解决方案-自类型泛型：父类的构建器设定为泛型（以存放子类的构建器），链式调用时返回泛型参数，子类构建器继承子类构建器 ：com.chen.effectivejava.item2.PClass.Builder
如果子类还会被继承则处理方法与当前父类构建器的处理方式一个
 问题2
描述：父类与子类各自的构建器的build()方法返回对应的对象类型，但父类构建器build()方法无法获悉子类的类型。
解决方案-协变返回类型：父类构建器build()直接返回父类，子类复写build()方法并修改方法的返回值：com.chen.effectivejava.item2.PClass.Builder#build
此时父类的构建器需要定义为抽象类强制子类构建器必须实现build()方法
如果子类还会被继承则处理方法也是如此
Item 3: Enforce the singleton property with a private constructor or an enum type（使用私有构造函数或枚举类型实施单例属性）
实现单例类的方案
急加载：基于类加载机制，类加载时同时创建唯一实例，单例使用频次不高时存在资源浪费。在单例类使用频繁的场景时可采用急加载方式，视具体的需求可以采用基于public static final类变量和工厂方法两个方案
延迟加载：首次使用时创建实例，需要解决并发环境下创建实例线程安全问题，包括指令重排的问题
基于内部类的实现方案：使用延时加载但创建时候使用内部类的类加载机制保证线程安全问题
枚举类方案：借助单值枚举类实现单例机制，是比较完美的解决方案，即简单又安全且没有资源浪费的问题
单例类实践指导：
私有构造器：单例类需要关闭构造器，即构造器不对外公开，枚举天然不公开构造器。
推荐方案：单例实现方案中急加载和枚举类比较简单，是比较推荐的方案。
安全问题：单例机制还需要在反射，克隆，系列化时避免创建第二实例，使用枚举类方案可以在这些场景下天然地保持单例。
拓展：
如果是继承体系下不能使用枚举作为单的实现方案（开发时枚举不支持继承）
不同单例实现方案下在反射，克隆，系列化时如何避免第二实例的创建
延迟加载方案下创建实例的线程安全问题，避免指令重排导致的第二实例的创建问题
item4：通过私有构造器强化不可实例化的能力
不可实例化类
定义：系统中存在一类不希望或者禁止实例化的类称为不可实例化类
应用场景：工具类或者辅助类可以考虑作为不可实例化类
经典案例：java.lang.Math，java.util.Arrays，java.util.Collections
不可实例化类的实现方案：
abstract方案：将类作为抽象类且抽象类不可被实例化，但abstract是强调强制继承并非强调不可实例化，若使用此方案则继承不可实例化类后就可以实例化相应的子类，因此abstract并不是一个完美的解决方案
private构造器：将构造器私有化，这时类就不允许创建实例的能力，注意此类也不能子类继承了（因此构造器私有之后继承后的子类也同样无法调用此类的构造器，不过不可实例化类应该考虑为禁止继承）
扩展：
private构造器同时也要考虑避免在反射&序列化&克隆场景被实例化，考虑在私有构造器中抛出异常
不可实例化类也可以考虑禁止继承
Item5:Prefer dependency injection to hardwiring resources（依赖注入优于硬连接资源）
资源类
定义：资源类是java程序中最常见的类，提供了一组相关的的业务服务和相应的功能。
资源引用
资源类会引用其他资源类，也可能会引用的工具类&辅助类
资源类规范地引用目标资源是一个重要的命题。
多状态特性：资源类是java面向对象的设计的核心类，与具体业务结合往往有多状态（子类）特性。

资源类vs工具类&辅助类
与资源类相对的就是工具类&辅助类，资源类提供业务相关的一组关联服务
而工具类&辅助类则倾向于系统底层实现为上层业务服务提供公用的功能。
工具类&辅助类

定义：工具类&辅助类在java程序中是为资源类服务的，工具类&辅助类的实现与系统底层关联，目标则是为资源类提供公共的功能接口。
单例特性：工具类&辅助类往往有单例特性或者有实例数有限，工具类&辅助类可以考虑以单例类或者不可实例化的形式在系统中出现。
底层特性：工具类与辅助类是面向系统底层细节的实现的，往往并不需要也不适合引用特定上层的资源类。工具类&辅助类引用的资源类时则需要重新确认设计方案。
资源引用的策略
硬连接：直接在资源对象内部对象中声明和创建相关的目标资源，绑定了目标资源实现提高的封装性但不利于解耦合。资源类引用底层或者其他资源时不建议使用硬连接。
依赖注入
原理：将基于场景或者实现的依赖引用从对象逻辑中分离出去，依赖注入是Java开发中一个流行的做法，被很多框架和工具或者项目采用
使用：资源对象内部仅作为资源引用的声明，具体的实现和实例由使用方自行设定，由此降底了耦合但增加资源使用的成本和项目的维护成本。使用依赖注入框架可完美配合依赖注入进入资源引用并扬长避短。
实现方案：不同场景下使用构造器&工厂方法或者Set方法&Supplier注入


Item 6: Avoid creating unnecessary objects（避免创建不必要的对象）

哪些对象需要避免重量创建
不可变对象：
描述事务固定状态的类，比如String，系统中没有必要创建多个不可变对象
可以考虑使用静态工厂封装不可变对象的创建，避免对象滥用和创建不必要的对象
单例对象也属于不可变对象


大型（重型）对象：
创建对象需要消耗大量时间和性能的对象就是大型对象，大型对象是需要考虑避免频繁创建的对象
可以考虑使用对象池，缓存大型对象减缓创建对象的性能消耗
避免对象创建的经典案例
String实例的matches对象传入一个正则时实例化一个正则表达比较昂贵，如何频繁对使用正则进行匹配不建议使用string.matches，而应该共用一个正则匹配对象
boolean变量的创建:Boolean.valueOf
适配器模式下，特定场景的适配器只创建一个就可以了
集合的视图类，基于同一个数据的集合视图类没有必要创建多个
基本类型性能好于其对应的对象类型，在基本数据类型够用的场景下避免相应对象类型的创建
避免重复创建对象的解决方案
定制对象创建逻辑-静态工厂方法
对象池:对大型对象维护对象池收益很高，目前有很多工具或者框架提供了我们直接可以使用的对象池
注意事项
避免不必要的对象创建，必意味着否定所有的对象的创建，某些创建下对某些对象的创建比对象复用还更有必要，特别在多线程环境下，对象不合理的复用反而更容易引用线程安全问题。
没有为一些对小型或者轻型对象维护特定的对象池，对象池本身也消耗，并且目前JVM对小型对象的创建与回收已经作了优化。
避免不可变对象&重型对象的创建时消耗，同理在序列化，克隆，反射时也应该避免相应的消耗。


Item 7: Eliminate obsolete object references（排除过时的对象引用）
过时对象问题的引入
经典案例1：手动实现一个基于数组的堆栈，弹出元素时仅修改栈顶下标，不对下标对应的元素进行置空
业务系统使用这个堆栈作为一个系统部件，当元素弹出时堆栈保留了对象的引用，而业务系统却不再使用这个对象
这个被堆栈保留却不被业务使用的对象，以及由其直接或者间接引用的对象（即使业务系统也不再使用）也不会进行内存释放
以上就造成一些对象不再起作用却占用内存，这里对过时对象的引用就造成的内存泄漏
经典案例2：侦听器与回调造成过时对象

假定实现了一个API这个API允许调用者通过回调对象进行获取，注意到回调对象的作用域或者生命周期往往是以功能代码相关而业务开发都往往察觉不出
如果提供回调的功能代码不合理往往回调对象就被成为过时对象，并在业务运行时积累，越来越多回调对象成为过时对象时就会造成导致系统故障的内存泄漏问题
经典案例3：对象池造成的过时

对象池用于解决或者避免大型对象的频繁创建造成的性能损耗，但当对象持有一个业务不使用或者很少使用的对象，也会成为一个过时对象从而造成内存泄漏问题
对象池可以关注一下对象的引用情况，对于不常用的对象使用合理的策略进行定期的清理，达到性能与内存损耗的平衡
过时对象

过时对象：业务不再使用的对象却被某些功能代码（模块）无意引用的对象
过时对象的问题：java垃圾回收算法，并不能准确区别业务代码和功能代码即一些对象不再被业务引用却被功能代引用时java仍然会认为是系统需要引用的对象，并且java并没有好的办法解决这个问题，需要业务或者开发者去关注过时对象的处理
过时对象引用的内存泄漏不是业务问题而是系统问题，但不管是业务问题还是系统性能问题，一样会影响业务系统的正常使用
排除过时对象的解决方案

手动解决：业务或者开发者自行识别过时对象，则对象过期手动置空，可配合垃圾回收算法工作
编程规范：
对象与变量一样，有定义部分也有作用域的概念。
编程时确保对象在相应的作用域中存在，不应该将对象引用随意超出相应的作用域。
对象作用域往往跟业务相关，大部分时间也需要开发关注。
WeakHashMap

如果对象相应的的key只被WeakHashMap引用时对象仍然可以被回收（通过WeakReference实现）
可以使用WeakHashMap作为功能代码持有对象的引用，当业务不再引用对象（即使功能代码引用了对象）时就可以将对象回收
可以考虑使用WeakHashMap作为对象池的底层实现


其他方案：
java.util.LinkedHashMap#removeEldestEntry：提供了增加元素之后清理过期元素项的工作
java.lang.ref：ref包提供了标记和处理过期对象的支持，如果业务开发中有需要对过期对象进行比较专业的处理时可以考虑使用ref包提供的支持。
事后方案：当系统频繁报出内存溢出，考虑检查过期对象的引用问题，可借助Heap剖析工具（HeapProfiler）定位问题
注意到不管是哪种过时对象处理的方案都脱离不了业务开者的关注，JDK暂时无法包办。


Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）
finalizer与cleaner
基本概念
finalizer:java.lang.Object#finalize
cleaner:java.lang.ref.Cleaner.Cleanable#clean
finalizer与cleaner是对象被JVM进行垃圾回收时回调的方法
finalizer与cleaner不应该作为业务资开发时资源关闭和回收的优先选择甚至应该避免，可考虑作为安全网为系统资源回收的最后保障
finalizer忽略了异常机制，cleaner是java9用于替换finalizer的API
注意事项

finalizer和cleaner是系统行为，不推荐使用finalizers和cleaners执行业务操作。
不应该优先使用finalizer和cleaner进行资源回释放和回收，因为finalizer&cleaner不保证及时回收不高效（回收资源时性能损耗大）甚至可能不执行回收，java提供的try-with-resours和try-finally更擅长进行资源关闭和回收
finalizer和cleaner执行依赖于JVM的垃圾回收算法：不同机器上垃圾回收算法及策略千差万别，这也导致了finalizer和cleaner不稳定不可靠且也不利于移值，甚于有些机器上垃圾回收并不保证finalizer和cleaner的执行
finalizer会忽略未捕获的异常：假设在finalize()方法尝试抛出一个异常则finalize()会停止运行，但此异常不会被捕获，这样对象的终结操作的完整性被破坏了，这时可能就产生了破坏的对象，万一这个破坏的对象（没有被完全回收的对象）再次被业务使用会就导致很多不确定的行为。
finalizer的安全问题：利用finalizer的忽略异常的机制可以制造安全问题，比如正常时对象构造器在创建对象过程中抛出异常异常抛出后则对象创建失败，但finalize()方法创建这个对象时抛出的异常被忽略导致创建出不完整的对象，将这个不完整的对象投递到系统中会对系统造成破坏。继承特定类（非final类）复写finalize()方法就可以轻易造成这个攻击。
作用

安全网：比如用户没有使用try-with-resources和try-finnal进行资源回收时，这时使用finalizer和cleaner进行强制资源回收（此时的资源回收和释放会比try-with-resources,try-final效率要低）以作为系统资源回收的兜底
回收效率与性能可接受的情况下可用于非java对象的资源回收和释放，但不可接受时还是仍然需要使用AutoCloseable配合try-with-resources&tyr-finally进行相应资源的释放


cleaner的实践指导

cleaner的实践指导
需要进行资源回收的资源类，声明并创建一个java.lang.ref.Cleaner变量cleaner
编写一个线程Runnable runnable收集资源的回收操作,runnable不可引用当前对象否则引起循环引用的问题，也不要使用lambda(lambda默认引用当前对象)
对象创建或者初始化时使用方法java.lang.ref.Cleaner#register将当前对象和runnalbe注册到cleaner，jvm对当前对象进行回收时会自动触发注册好的资源回收操作
Item 9: Prefer try-with-resources to try-finally（使用 try-with-resources 优于 try-finally）

try-with-resources&try-finalle
基本概念
try-with-resources与try-finally都用于进行关闭和回收资源的操作
try-with-resources是JDK7引入的可配合AutoCloseable接口对资源执行关闭操作


try-with-resources对资源关闭和回收操作的优化

try-finally需要开发者使用资源手动关闭和释放资源，try-with-resources则配合AutoCloseable提供了统一的资源关闭的回收操作，资源关闭和回收时try-with-resources往往优于try-finally
特定业务代码使用多个资源对象需要逐个对多个资源对象进行关闭时try-resources更加适用
try-finally中finally语句也会抛出异常，如果try与finally则finally报出的异常会覆盖try抛出的异常，而往往try抛出的异常更有利于业务问题的定位，使用try-resources则资源对象使用过程中异常会被优先抛出同时关闭操作发生的异常也可以通过特定接口（getSuppressed）获取出来
try-with-resources与try-finally的演示

try-with-resources在统一关闭多个资源对象时的优势
try-with-resource在资源对象使用和资源对象关闭都抛出异常的表示 
try-finally在资源对象使用和资源对象关闭时都抛出异常时的表现
Item 10: Obey the general contract when overriding equals（覆盖 equals 方法时应遵守的约定）
equals方法相关的概念
值类对象&功能对象
值类对象：对象用于代表或者强调特定的状态或者取值，比如POJO，VO类
功能对象：强调功能或者逻辑处理代码的封装对象，是为提供服务或者功能而设计的对象
判断值类对象是否相等时往往依据对象的字段内容进行判定而不是内存地址
业务系统较少对功能对象进行equals操作或者大多数使用内存地址可以作为equals的判断依据
equals的默认实现

==操作，直接判定两边的对象引用是不是指向同一个内存地址
Object对象提供了equals方法的默认实现，直接使用==判断两个对象是否相等
综上equals默认实现是通过对象的内存地址判断两个对象是否是同一个对象
equals的用处
业务系统中判断对象是否相等（逻辑相等），可以通过调用equals进行判定
对象加入Map或者Set集合时，需要对它equals介定对象是否相等
对象比较时也可能使用equals方法
equals通用约定与解释
约定名称	定义	造成后果	经典案例
自反性	x.equals(x)恒定返回true	集合类contains将返回错误的结果	URL的equals

对称性	x.equals(y)与y.equals(x)结果恒定相等	元素加入顺序，影响集合类contains的结果	扩展实例化类时即增加新的值组件又保留equals时父子对象之间的比较
传递性	x.equals(y) &y.equals(z)与x.equals(z)结果相同	可能导致contains返回错误结果	扩展实例化类时即增加新的值组件又保留equals时，子类->父类->子类很容易出现违反传递性的案例
一致性	x,y不变时多次调用x.equals(y)恒定返回一个结果，特别对于不可变对象时特别关注一致性问题	集合类contains将返回错误的结果
	URL的equals
非空性	x.equals(null)恒等false	
	



equals的使用场景分析

不应该复写equals方法的场景
类的每个实例本质上是唯一的：即业务系统判定对象唯一性就是使用对象内存地址，比如大多数功能对象，单例对象
业务系统不需要对该类比较操作这时直接使用默认实现，如果是直接想禁用对象比较操作则可以直接复写equals方法以抛出一个运行时异常
该类的equals可以直接复用超类的equals方法：子类和父类各自有equals方法，当涉及子类与父类的比较时就可能违对称性与传递性，特别值类对象子类增加父类没有的字段时而这个字段也参数equals的判定时就会违反对称性的传递性，导致业务问题
单例类&枚举类通常使用不需要复写equals
应该复写equals的场景

业务系统需要对该对象进行逻辑比较并且equals的默认实现不足于表达业务业务系统对对象进行逻辑相等的操作
业务系统中值类对象用于逻辑比较时需要考虑复写equals以实现业务相关的逻辑相等的处理
加入Map或者Set的对象可以考虑是否需要复写equals方法


复写euqals的经典场景

String:String对象修改Object中提供的equals默认实现
枚举类是典型的值类对象，java已经提供了区别与object提供equals的默认实现
复写equals方法经典问题-无法在扩展实例化类时即增加新的值组件又保留equals
问题描述：父类并添加一个值组件形成子类，此值组件参与的子类的equals但不参与父类的euqals
解决方案1-使用组合：当值类对象各有的equals方法时业务系统可以考虑使用组合而不是继承实现字段包含，从而避免值类对象继承时使用euqals违反对称性的传递性的问题
解决方案2-父类不可实例化：值类对象各自有equals方法且使用继承体系的值类对象，考虑禁用父类的实例化，将父类标志为abstract
解决方案3-开发时自行避免：值类对象各自有equals方法且使用继承体系的值类对象，则避免父子间比较带来的隐患，特别是在加入Map或者Set中的时候，java.sql.Timestamp和java.util.Date就是一个不良好的示范
复写equals方法的最佳实践
审视复写equals方法的必要性
很多时候，特别是活动对象，Object提供的默认实现就已经足够满足业务需求（逻辑）
考虑使用可靠的框架或者工具生成对象的equals方法-比如谷歌开源的AutoValue
使用IDE自动生成equals方法，至少可以避免人为的粗心的错误
必要的前置判断 

自反性判断：使用==判断对象引用是否一致，符合自反性
类型判断和转换：使用instanceof进行类型判断和转换，严格限定可被比较的类型避免出现父子间比较的对称性问题，一般只接受当前类的实例，也可以基于接口决定可接受的类型如Map,List,Set等
非空性判断：判断传递参数是否为null，为null时恒定返回false,符合非空性


关于对象字段数值类型equals比较的最佳实践

浮点数据：float,double类型的字段使用static Float.compare(float,float),Double.compare(double, double)，以便考虑对Float.NaN、-0.0f 和类似的双重值的equals操作，具体可以查看源码 
基本数字类型：基本数据类型的equlas方法，避免使用对应的包装类以减少自动装箱带来的性能耗损
数组：数组类型字段使用Arrays.equals方法
对象类型：对象类型的字段，使用Objects.equals(Objects.equals增加对象引用判空的操作)
可变类与不可变类的equals操作：equals操作尽量保持最小的可变性，对象可能发生变化则需要及时跟进
关于对象字段equals策略的最佳实践

为了获得最佳性能，首先比较那些更可能不同、比较成本更低的字段
不能比较不属于对象逻辑状态的字段，例如用于同步操作的锁字段。
派生字段（派生字段是由对象其他字段可以计算或者推断出来的），派生字段与被派生字段的equals操作考虑只保留一种，比如需要一个多边形类是否相等，面积是派生字段，如果面积不相等，就不需要比较它们的边。
审视equals方法是否符合通用约定和一些警告
